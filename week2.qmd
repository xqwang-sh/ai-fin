---
title: "第2讲：资产定价中的机器学习应用"
subtitle: "问题解构、特征工程与时序评估规范"
---

## 资产定价预测的"特别之处"

### 与典型监督学习的差异

:::{.callout-important}
🎯 核心认知

资产定价预测**远比标准 i.i.d. 监督学习困难**，原因在于：

1. **极低信噪比**：可预测成分通常 < 5% 方差
2. **非平稳性**：数据分布随时间变化
3. **横截面相关**：资产间高度关联
4. **交易约束**：预测好 ≠ 可交易 ≠ 能赚钱
:::

#### 低信噪比（Low Signal-to-Noise Ratio）

**典型事实**（来自 Gu, Kelly, Xiu 2020）：

- 个股月度收益预测的 $R^2_{\text{OOS}} \approx 0.5\%$
- 即使最优模型，95%+ 方差仍是噪声
- 对比：图像分类任务 $R^2 > 90\%$

**含义**：

- 复杂模型极易将噪声误认为信号
- 正则化与集成方法至关重要
- 评估指标需关注**排序能力**而非绝对预测精度

#### 非平稳性（Non-stationarity）

**表现**：

- 均值/方差随时间变化（如牛市 vs 熊市）
- 特征–收益关系不稳定（如价值因子的衰退）
- 新信息源出现（如社交媒体数据）

**挑战**：

- 历史数据未必代表未来
- 模型需定期重训练
- 需检验不同市场状态下的稳健性

#### 横截面相关性（Cross-sectional Dependence）

**现实**：

- 股票收益受共同因子驱动（市场、行业、风格）
- 相关性在危机时期飙升
- 违反 i.i.d. 假设中的"独立性"

**影响**：

- 标准误估计偏小（需聚类调整）
- 组合风险管理更复杂
- 需控制因子暴露

#### 交易约束与成本

**现实约束**：

- **流动性**：小市值股票难以大规模交易
- **交易成本**：佣金、冲击成本、税费
- **卖空限制**：部分市场卖空困难或成本高
- **杠杆限制**：借贷成本与上限

:::{.callout-warning}
⚠️ 为何"预测更准"不等于"更赚钱"？

**案例**：模型 A 预测 IC = 0.08，模型 B 预测 IC = 0.06

- 若模型 A 的信号波动大 → 高换手率 → 交易成本吞噬收益
- 若模型 A 偏好小市值股 → 流动性不足 → 难以实施
- **结论**：模型 B 可能成本后表现更好
:::

## 问题解构与特征工程

### 预测对象的选择

#### 个股收益（Individual Stock Returns）

$$
r_{i,t+h} = \log\left(\frac{P_{i,t+h}}{P_{i,t}}\right)
$$

- **优点**：直接可交易，信息丰富
- **缺点**：噪声大，需处理退市/分红

#### 超额收益（Excess Returns）

$$
r^e_{i,t+h} = r_{i,t+h} - r_{f,t+h}
$$

或对市场调整：

$$
r^e_{i,t+h} = r_{i,t+h} - r_{m,t+h}
$$

- **优点**：去除市场共同成分，提升信噪比
- **缺点**：需选择基准

#### 多空组合收益（Long-Short Portfolio Returns）

根据预测信号构建分位数组合：

$$
r^{LS}_{t+h} = r^{\text{High}}_{t+h} - r^{\text{Low}}_{t+h}
$$

- **优点**：直接评估策略表现
- **缺点**：损失个股级信息

### 特征工程：信息集与时间对齐

#### 信息可得性规则（Information Availability）

:::{.callout-important}
🔑 黄金法则

**在时刻 $t$ 用于预测的特征，必须在 $t$ 时刻已公开可得！**
:::

**常见陷阱**：

1. **会计变量披露滞后**

```
错误：用 2023 年报数据预测 2023 年收益
正确：用 2022 年报（2023年4月披露）预测 2023年5月后收益
```

2. **价格数据的"收盘价陷阱"**

```
错误：用 t 日收盘价预测 t 日收益
正确：用 t-1 日收盘价预测 t 日收益
```

3. **分析师预测的"修订滞后"**

```
需记录：每个预测的发布时间戳
对齐：只用发布时间 < t 的预测
```

#### 特征类别与对齐策略

| 特征类别 | 更新频率 | 披露滞后 | 对齐策略 |
|---------|---------|---------|---------|
| **价格/成交量** | 日 | 无 | 用 $t-1$ 预测 $t$ |
| **会计变量** | 季/年 | 1-4 个月 | 记录披露日期 |
| **分析师预测** | 不定期 | 无 | 记录时间戳 |
| **新闻/文本** | 实时 | 几乎无 | 记录发布时间 |
| **宏观经济** | 月/季 | 数周 | 记录发布日期 |

#### 缺失值处理的时间规范

**原则**：填补方法不能使用未来信息。

✅ **正确做法**：

```python
# 前向填充（用最近的已知值）
df['feature'] = df.groupby('stock_id')['feature'].ffill()

# 或用历史均值（仅用 t 之前数据）
df['feature'] = df['feature'].fillna(df['feature'].expanding().mean())
```

❌ **错误做法**：

```python
# 用全局均值（包含未来数据）
df['feature'] = df['feature'].fillna(df['feature'].mean())
```

### 标准化的时间规范

**横截面标准化**（cross-sectional）：

$$
\tilde{x}_{i,t} = \frac{x_{i,t} - \bar{x}_t}{\sigma_t}
$$

其中 $\bar{x}_t, \sigma_t$ 是时刻 $t$ 的横截面均值/标准差。

✅ **适用场景**：特征在不同时期量纲差异大（如市盈率）

**时间序列标准化**：

$$
\tilde{x}_{i,t} = \frac{x_{i,t} - \bar{x}_{i,<t}}{\sigma_{i,<t}}
$$

其中 $\bar{x}_{i,<t}, \sigma_{i,<t}$ 是股票 $i$ 在 $t$ **之前**的均值/标准差。

✅ **适用场景**：特征在不同股票间量纲差异大（如成交量）

:::{.callout-warning}
⚠️ 避免信息泄露

**错误**：用包含测试期的统计量标准化

```python
# 错误！scaler 看到了测试集数据
scaler.fit(X_train + X_test)
```

**正确**：仅用训练期拟合

```python
# 正确！
scaler.fit(X_train)
X_train_scaled = scaler.transform(X_train)
X_test_scaled = scaler.transform(X_test)  # 用训练期参数转换
```
:::

## 时序数据评估规范

### 为什么 K 折交叉验证不适用？

**K 折 CV 的假设**：训练集和验证集可互换（i.i.d.）

**金融时序的现实**：

- 未来不可用于预测过去（因果性）
- 数据分布随时间变化（非平稳）
- 若打乱时间顺序，会造成严重的**前瞻偏误**

:::{.callout-caution}
🚫 禁止操作

```python
# 危险！时序数据不能用标准 K 折
from sklearn.model_selection import KFold
kf = KFold(n_splits=5, shuffle=True)  # shuffle=True 破坏时序
```
:::

### 时序数据的正确划分

#### 基本时间切分

```
历史数据  │  样本内评估期  │  样本外评估期
─────────┼───────────────┼──────────────→ 时间
  Train  │    Validation │      Test
```

**原则**：

- 训练集：最早的数据
- 验证集：训练集之后
- 测试集：验证集之后（仅用一次！）

#### 滚动窗口（Rolling Window）

**固定训练窗口长度**，逐步向前滚动：

```
时间:  1 2 3 4 5 6 7 8 9 10 11 12

迭代1: [Train: 1-5] → Predict: 6
迭代2:   [Train: 2-6] → Predict: 7
迭代3:     [Train: 3-7] → Predict: 8
迭代4:       [Train: 4-8] → Predict: 9
...
```

**优点**：

- 模型保持"新鲜"，适应非平稳性
- 计算成本可控

**缺点**：

- 丢弃早期数据，样本量小
- 窗口长度需调优

#### 扩展窗口（Expanding Window）

**累积所有历史数据**，窗口不断扩大：

```
时间:  1 2 3 4 5 6 7 8 9 10 11 12

迭代1: [Train: 1-5] → Predict: 6
迭代2: [Train: 1-6] → Predict: 7
迭代3: [Train: 1-7] → Predict: 8
迭代4: [Train: 1-8] → Predict: 9
...
```

**优点**：

- 充分利用历史数据，样本量大
- 估计更稳定

**缺点**：

- 早期数据可能过时
- 计算成本高（训练集不断增长）

#### 选择建议

| 场景 | 推荐方法 |
|-----|---------|
| 数据平稳、样本少 | 扩展窗口 |
| 数据非平稳明显 | 滚动窗口（短窗口）|
| 不确定 | 两者都试，对比稳健性 |

### 嵌套时序评估（Nested Time Series CV）

**问题**：超参数（如正则化强度 $\lambda$）如何选择？

**错误做法**：在测试集上调参（数据窥探！）

**正确做法**：嵌套结构，分离"调参"与"泛化评估"

#### 嵌套结构示意

```
外层循环（泛化评估）:
┌────────────────────────────────────────────────────┐
│ Train + Val (合并) │ → Model(best λ) → │ Test_1    │
└────────────────────────────────────────────────────┘
    内层循环（选 λ）:
    ┌──────────────────┬─────────────┐
    │   Train_inner    │  Val_inner  │  → 试 λ1, λ2, ...
    └──────────────────┴─────────────┘

然后滚动到下一期...

┌────────────────────────────────────────────────────┐
│   Train + Val (合并)   │ → Model(best λ) → │Test_2  │
└────────────────────────────────────────────────────┘
    内层循环（重新选 λ）:
    ┌──────────────────┬─────────────┐
    │   Train_inner    │  Val_inner  │
    └──────────────────┴─────────────┘
```

#### 伪代码

```python
test_scores = []

for test_start in test_periods:
    # 外层：定义本期测试集
    train_val = data[data.date < test_start]
    test = data[data.date >= test_start]
    
    # 内层：在 train_val 上用时序 CV 选超参数
    best_lambda = None
    best_val_score = -inf
    
    for lambda_candidate in lambda_grid:
        val_scores_inner = []
        for val_start in validation_periods:
            train_inner = train_val[train_val.date < val_start]
            val_inner = train_val[train_val.date >= val_start]
            
            model.fit(train_inner, lambda=lambda_candidate)
            val_scores_inner.append(model.score(val_inner))
        
        avg_val_score = mean(val_scores_inner)
        if avg_val_score > best_val_score:
            best_val_score = avg_val_score
            best_lambda = lambda_candidate
    
    # 外层：用最优超参数训练最终模型
    model.fit(train_val, lambda=best_lambda)
    test_scores.append(model.score(test))

# 报告样本外性能
final_oos_score = mean(test_scores)
```

:::{.callout-tip}
💡 实践建议

- **内层窗口可以更短**：调参不需要太长历史
- **外层跨度看研究问题**：月度/季度/年度重训练
- **计算成本高**：可先在小数据集上探索，再全量运行
:::

## 回测卫生清单（Backtesting Hygiene）

### 常见偏误类型

#### 存活偏误（Survivorship Bias）

**问题**：只用当前仍存在的股票回测，忽略退市股票。

**后果**：

- 高估策略收益（退市股通常表现差）
- 低估风险（极端亏损被排除）

**解决**：

- 使用**包含退市股的全历史数据库**
- 记录退市日期与退市收益

#### 数据回填（Backfilled Data）

**问题**：数据供应商事后修正历史数据（如重述财报）。

**后果**：用到了当时不可得的"修正后"数据。

**解决**：

- 使用**时间点数据库**（point-in-time database）
- 记录每个数据点的"as of"日期

#### 公司行动处理（Corporate Actions）

**未调整**：

- 股票分拆/合并（如1股拆3股）
- 现金分红（影响收益计算）
- 配股/增发

**解决**：

- 使用**复权价格**（adjusted prices）
- 或手动调整收益序列

#### 停牌处理

**问题**：停牌期间无法交易，但收益率序列可能显示"0"或"缺失"。

**后果**：

- 错误假设可以在停牌期买入/卖出
- 低估流动性风险

**解决**：

- 标记停牌日期
- 回测中跳过停牌股票或延迟调仓

#### 样本选择与数据窥探（Data Snooping）

**问题**：

- 在多次尝试后只报告最好的结果
- 根据整个样本期的特征选择模型/特征

**后果**：

- 样本外表现远低于预期
- 无法复现

**解决**：

- **预先登记**研究设计（pre-registration）
- 报告所有尝试（包括失败的）
- 用**独立测试集**或**新数据期**验证

### 调仓时点与执行滞后

#### 调仓时点设计

**典型流程**：

```
月末 t: 观察所有可得信息 x_t
  ↓
月初 t+1: 计算预测信号 f(x_t)
  ↓
开盘后: 执行交易，形成新组合
  ↓
月末 t+1: 观察收益 r_{t+1}
```

**关键问题**：

1. 何时计算信号？（需确保数据已可得）
2. 何时执行交易？（开盘/收盘/盘中均价？）
3. 是否有执行滞后？（如需 T+1 日才能成交）

#### 执行价格

**保守假设**：

- 买入用**更高的价格**（如开盘价 + 滑点）
- 卖出用**更低的价格**（如开盘价 - 滑点）

**示例**：

```python
# 假设在月初第一个交易日开盘价执行
entry_price = open_price * (1 + slippage)  # 买入
exit_price = open_price * (1 - slippage)   # 卖出
```

## 评估指标：从预测到组合

### 预测层面指标

#### 样本外 $R^2$（Out-of-Sample $R^2$）

$$
R^2_{\text{OOS}} = 1 - \frac{\sum_{t \in \text{OOS}} (r_t - \hat{r}_t)^2}{\sum_{t \in \text{OOS}} (r_t - \bar{r}_{\text{hist}})^2}
$$

其中 $\bar{r}_{\text{hist}}$ 是历史均值（仅用训练期）。

**解释**：

- 相对于"历史均值预测"的改进
- 可能为负（模型比均值还差）
- GKY (2020) 中 $R^2_{\text{OOS}} \approx 0.5\%$ 已属优秀

#### 信息系数（IC）与 Rank IC

**IC**（Information Coefficient）：预测值与实际值的相关系数

$$
\text{IC}_t = \text{Corr}(\hat{r}_{i,t}, r_{i,t})
$$

**Rank IC**：排序相关（Spearman）

$$
\text{Rank-IC}_t = \text{Spearman}(\hat{r}_{i,t}, r_{i,t})
$$

**优点**：

- 更关注排序而非数值精度
- 对异常值更鲁棒（Rank IC）

**典型值**：

- $|\text{IC}| > 0.05$ 已有实用价值
- $|\text{IC}| > 0.10$ 属强信号

### 组合层面指标

#### 构建多空组合

**基于预测分数排序**：

1. 每期将股票按 $\hat{r}_{i,t}$ 排序
2. 做多前 20%（或前十分位）
3. 做空后 20%（或后十分位）
4. 计算组合收益

#### 年化超额收益

$$
\bar{r}^e_{\text{annual}} = 12 \times \frac{1}{T}\sum_{t=1}^T r^e_t \quad \text{（月度数据）}
$$

#### 夏普比率（Sharpe Ratio）

$$
\text{Sharpe} = \frac{\bar{r}^e}{\sigma(r^e)} \times \sqrt{12}
$$

**解释**：单位风险的超额收益

**典型值**：

- Sharpe > 1：优秀
- Sharpe > 2：非常优秀（需警惕过拟合）

#### 信息比率（Information Ratio）

$$
\text{IR} = \frac{\bar{r}^e - r^{\text{benchmark}}}{\sigma(r^e - r^{\text{benchmark}})}
$$

**解释**：相对基准的超额收益稳定性

#### 最大回撤（Maximum Drawdown）

$$
\text{MDD} = \max_{t} \left[\max_{s \leq t} \text{Cumulative Return}_s - \text{Cumulative Return}_t\right]
$$

**解释**：从峰值到谷底的最大损失

#### 换手率（Turnover）

$$
\text{Turnover}_t = \frac{1}{2}\sum_{i} |w_{i,t} - w_{i,t-1}^+|
$$

其中 $w_{i,t-1}^+$ 是 $t-1$ 期末持仓权重（考虑价格变化）。

**重要性**：

- 高换手 → 高交易成本
- 需权衡信号强度与稳定性

#### 成本后净收益

$$
r^{\text{net}}_t = r^{\text{gross}}_t - \text{Cost}_t
$$

**成本构成**：

- **佣金**：$c \times \text{Turnover}_t$（如 $c = 0.1\%$）
- **冲击成本**：$\alpha \times \sqrt{\text{Trade Size}}$
- **融券费用**：做空头寸的借券成本

:::{.callout-warning}
⚠️ 成本往往被低估

- 小市值股票冲击成本远超大盘股
- 危机时期融券费用飙升
- 实际执行中的滑点
:::

### 切片评估与稳健性检验

#### 时间切片

**不同市场状态**：

- 牛市 vs 熊市
- 高波动 vs 低波动
- 危机期 vs 平稳期

**检验**：策略是否在各时期稳健？

#### 横截面切片

**不同资产特征**：

- 大市值 vs 小市值
- 高流动性 vs 低流动性
- 不同行业/板块

**检验**：策略收益来源是否过于集中？

#### 稳健性检验

1. **换窗口长度**：滚动窗口 3年 vs 5年
2. **换再平衡频率**：月度 vs 季度
3. **换组合构建**：等权 vs 市值加权
4. **剔除极端期**：去掉危机月份，策略是否仍有效？

## 模型选择与组合构建

### 模型性能对比（参照 GKY 2020）

#### 主要发现

| 模型类别 | $R^2_{\text{OOS}}$ | 夏普比率 | 优点 | 缺点 |
|---------|-------------------|----------|-----|-----|
| **线性（Lasso/Elastic Net）** | 0.30% | 1.2 | 可解释，稳定 | 表达力有限 |
| **树模型（Random Forest, GBM）** | 0.40% | 1.5 | 捕捉非线性，重要性解释 | 易过拟合 |
| **神经网络（DNN）** | 0.50% | 1.6 | 最强表达力 | 黑箱，不稳定 |
| **组合（Ensemble）** | **0.55%** | **1.7** | 稳健性最佳 | 复杂度高 |

#### 核心结论

1. **非线性方法表现更好**，但优势有限（0.1-0.2% $R^2$）
2. **模型组合**优于单一模型（分散过拟合风险）
3. **正则化至关重要**（无论线性还是非线性）

### 从预测到组合的映射

#### 简单排序（Rank-based）

```python
# 每期按预测分数排序
scores = model.predict(X_t)
ranks = scores.argsort()

# 构建多空组合
long = ranks[-n_top:]   # 前 n 名
short = ranks[:n_top]   # 后 n 名

portfolio = equal_weight(long) - equal_weight(short)
```

**优点**：简单，鲁棒

**缺点**：忽略预测强度差异

#### 比例权重（Proportional）

$$
w_i \propto \hat{r}_i
$$

归一化使 $\sum w_i = 1$。

**优点**：利用预测强度信息

**缺点**：对极端预测敏感

#### 均值-方差优化（Mean-Variance）

$$
\max_{\mathbf{w}} \quad \mathbf{w}^\top \hat{\boldsymbol{\mu}} - \frac{\lambda}{2} \mathbf{w}^\top \hat{\boldsymbol{\Sigma}} \mathbf{w}
$$

其中 $\hat{\boldsymbol{\mu}}$ 是预测收益，$\hat{\boldsymbol{\Sigma}}$ 是协方差矩阵。

**优点**：考虑风险

**缺点**：

- 协方差矩阵估计误差大
- 对输入高度敏感（需正则化）

#### 因子约束（Factor-neutral）

控制对已知因子的暴露：

$$
\mathbf{w}^\top \mathbf{F} = \mathbf{0}
$$

其中 $\mathbf{F}$ 是因子载荷矩阵（如市场、规模、价值）。

**优点**：纯粹的 alpha，风险更可控

### 模型组合策略

#### 简单平均（Simple Average）

$$
\hat{r}^{\text{ens}}_i = \frac{1}{M}\sum_{m=1}^M \hat{r}^{(m)}_i
$$

**优点**：最简单，通常效果好

#### 加权平均（Weighted Average）

$$
\hat{r}^{\text{ens}}_i = \sum_{m=1}^M w_m \hat{r}^{(m)}_i
$$

权重 $w_m$ 根据验证集表现确定。

#### Stacking

训练一个**元模型**，以各模型预测为输入：

```
模型1预测 ──┐
模型2预测 ──┼──→ 元模型 ──→ 最终预测
模型3预测 ──┘
```

**优点**：自动学习最优组合

**缺点**：增加过拟合风险（需嵌套 CV）

## 本周小结

### 核心要点

1. **金融预测的特殊挑战**：低信噪比、非平稳、交易约束
2. **信息可得性**：特征对齐、披露滞后、无前瞻偏误
3. **时序评估**：滚动/扩展窗口、嵌套 CV、禁用标准 K 折
4. **回测卫生**：存活偏误、数据回填、执行滞后等
5. **评估体系**：预测指标（IC）+ 组合指标（Sharpe, 成本后收益）
6. **模型选择**：正则化、集成、预测到组合的映射

### 本周思考题

#### 问题 1

一个拥有较高样本外预测指标（如 OS-$R^2$ 或 IC）的模型,为何在真实交易中仍可能表现很差？请至少列出三个原因，并指出它们分别对应哪一类"回测卫生"问题或"经济约束"。

:::{.callout-note collapse="true"}
💡 参考答案

1. **交易成本**（经济约束）
   - 高换手率策略的佣金与冲击成本
   - 可能吞噬全部预测收益

2. **流动性不足**（经济约束）
   - 信号偏好小市值股票
   - 大资金无法实际交易

3. **执行滞后**（回测卫生）
   - 回测假设即时执行
   - 实际可能 T+1 或更晚，信号衰减

4. **数据窥探**（回测卫生）
   - 在测试集上反复调参
   - 样本外真实表现被高估

5. **市场冲击**（经济约束）
   - 大额交易改变价格
   - 回测未考虑自身交易的影响
:::

#### 问题 2

如果你的特征中包含会计变量（存在披露滞后），滚动窗口评估中最常见的信息泄露路径是什么？你会如何在数据对齐上规避？

:::{.callout-note collapse="true"}
💡 参考答案

**常见泄露路径**：

用当期年报数据预测当期收益，忽略年报通常在次年 3-4 月才披露。

**规避方法**：

1. **记录披露日期**
   ```python
   df['report_date']     # 报告期（如 2023-12-31）
   df['announce_date']   # 实际披露日（如 2024-04-30）
   ```

2. **对齐规则**
   ```python
   # 只用已披露的最新数据
   df = df[df['announce_date'] < df['trade_date']]
   ```

3. **保守假设**
   - 年报假设次年 5 月 1 日可得
   - 季报假设下一季度首月可得
:::

#### 问题 3

结合 Gu, Kelly, Xiu (2020) 的经验事实，你会如何在"预测性能—稳定性—可解释性"之间权衡选择模型，并将其输出转化为一个可交易的组合？

:::{.callout-note collapse="true"}
💡 参考答案

**权衡策略**：

1. **预测性能**：神经网络 > 树模型 > 线性
   - 但边际提升有限（0.1-0.2% $R^2$）

2. **稳定性**：线性 ≈ 模型组合 > 树模型 > 神经网络
   - 金融低信噪比环境下，稳定性更重要

3. **可解释性**：线性 > 树模型 > 神经网络
   - 监管与风控需求

**推荐方案**：

- **研究导向**：使用线性（Elastic Net）作为基准，树/神经网络探索非线性
- **实盘导向**：多模型组合（平均或 stacking），平衡性能与稳健性
- **转化为组合**：
  1. 按预测分数排序
  2. 做多前十分位，做空后十分位
  3. 等权或根据流动性调整权重
  4. 月度再平衡，控制换手率 < 50%
:::

---

### 下周预告

第3周进入**文本分析**领域：

- 文本表示方法演进（词袋 → BERT）
- 语料治理：版本、对齐、去噪
- 从原始文档到可用变量的审计流程
- 增量信息检验与经济含义

**预习阅读**：

- Eisfeldt & Schubert (2024) *Generative AI and Finance*
- Gentzkow, Kelly & Taddy (2019) *Text as Data*
- Ludwig, Mullainathan & Rambachan (2025) *LLMs: an applied econometric framework*

**预习任务**：选一种感兴趣的金融文本（年报/新闻/研报/社媒），思考它最容易产生的"前瞻/对齐错误"是什么。
